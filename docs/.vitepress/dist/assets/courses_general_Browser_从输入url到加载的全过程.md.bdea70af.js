import{_ as o}from"./chunks/ArticleMetadata.839094c8.js";import{_ as s,i as p,o as i,c as d,g as _,w as c,e as u,v as S,b as r,f as m,a as w}from"./app.59cdf3da.js";const U=JSON.parse('{"title":"从输入URL到页面加载的全过程","description":"","frontmatter":{"title":"从输入URL到页面加载的全过程","author":"Itway","date":"2022/12/29 21:38","categories":["通用知识集"],"tags":["浏览器"]},"headers":[],"relativePath":"courses/general/Browser/从输入url到加载的全过程.md","lastUpdated":1746545041000}'),f={name:"courses/general/Browser/从输入url到加载的全过程.md"},h=r("h1",{id:"从输入-url-到页面加载的全过程",tabindex:"-1"},[m("从输入 URL 到页面加载的全过程 "),r("a",{class:"header-anchor",href:"#从输入-url-到页面加载的全过程","aria-hidden":"true"},"#")],-1),T=w('<ol><li><p>首先在浏览器中输入 URL</p></li><li><p>查找缓存：浏览器先查看浏览器缓存-系统缓存-路由缓存中是否有该地址页面，如果有则显示页面内容。如果没有则进行下一步。</p><ul><li>浏览器缓存：浏览器会记录 DNS 一段时间，因此，只是第一个地方解析 DNS 请求；</li><li>操作系统缓存:如果在浏览器缓存中不包含这个记录，则会使系统调用操作系统， 获取操作系统的记录(保存最近的 DNS 查询缓存)；</li><li>路由器缓存：如果上述两个步骤均不能成功获取 DNS 记录，继续搜索路由器缓存；</li><li>ISP 缓存：若上述均失败，继续向 ISP 搜索。</li></ul></li><li><p>DNS 域名解析：浏览器向 DNS 服务器发起请求，解析该 URL 中的域名对应的 IP 地址。DNS 服务器是基于 UDP 的，因此会用到 UDP 协议。</p></li><li><p>建立 TCP 连接：解析出 IP 地址后，根据 IP 地址和默认 80 端口，和服务器建立 TCP 连接</p></li><li><p>发起 HTTP 请求：浏览器发起读取文件的 HTTP 请求，，该请求报文作为 TCP 三次握手的第三次数据发送给服务器</p></li><li><p>服务器响应请求并返回结果：服务器对浏览器请求做出响应，并把对应的 html 文件发送给浏览器</p></li><li><p>关闭 TCP 连接：通过四次挥手释放 TCP 连接</p></li><li><p>浏览器渲染：客户端（浏览器）解析 HTML 内容并渲染出来，浏览器接收到数据包后的解析流程为：</p><ul><li>构建 DOM 树：词法分析然后解析成 DOM 树（dom tree），是由 dom 元素及属性节点组成，树的根是 document 对象</li><li>构建 CSS 规则树：生成 CSS 规则树（CSS Rule Tree）</li><li>构建 render 树：Web 浏览器将 DOM 和 CSSOM 结合，并构建出渲染树（render tree）</li><li>布局（Layout）：计算出每个节点在屏幕中的位置</li><li>绘制（Painting）：即遍历 render 树，并使用 UI 后端层绘制每个节点。</li></ul></li><li><p>JS 引擎解析过程：调用 JS 引擎执行 JS 代码（JS 的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）</p><ul><li>创建 window 对象：window 对象也叫全局执行环境，当页面产生时就被创建，所有的全局变量和函数都属于 window 的属性和方法，而 DOM Tree 也会映射在 window 的 doucment 对象上。当关闭网页或者关闭浏览器时，全局执行环境会被销毁。</li><li>加载文件：完成 js 引擎分析它的语法与词法是否合法，如果合法进入预编译</li><li>预编译：在预编译的过程中，浏览器会寻找全局变量声明，把它作为 window 的属性加入到 window 对象中，并给变量赋值为&#39;undefined&#39;；寻找全局函数声明，把它作为 window 的方法加入到 window 对象中，并将函数体赋值给他（匿名函数是不参与预编译的，因为它是变量）。而变量提升作为不合理的地方在 ES6 中已经解决了，函数提升还存在。</li><li>解释执行：执行到变量就赋值，如果变量没有被定义，也就没有被预编译直接赋值，在 ES5 非严格模式下这个变量会成为 window 的一个属性，也就是成为全局变量。string、int 这样的值就是直接把值放在变量的存储空间里，object 对象就是把指针指向变量的存储空间。函数执行，就将函数的环境推入一个环境的栈中，执行完成后再弹出，控制权交还给之前的环境。JS 作用域其实就是这样的执行流机制实现的。</li></ul></li></ol><p>传送门</p><p>☞ # DNS 域名解析过程：<a href="https://juejin.cn/post/7005468491067162655" target="_blank" rel="noreferrer">https://juejin.cn/post/7005468491067162655</a></p><p>☞# 浏览器的工作原理：<a href="https://juejin.cn/post/6992597760935460901" target="_blank" rel="noreferrer">https://juejin.cn/post/6992597760935460901</a></p>',4);function P(e,C,D,N,g,j){const a=o,n=p("ClientOnly");return i(),d("div",null,[h,_(n,null,{default:c(()=>{var t,l;return[(((t=e.$frontmatter)==null?void 0:t.aside)??!0)&&(((l=e.$frontmatter)==null?void 0:l.showArticleMetadata)??!1)?(i(),u(a,{key:0,article:e.$frontmatter},null,8,["article"])):S("",!0)]}),_:1}),T])}const M=s(f,[["render",P]]);export{U as __pageData,M as default};

import{_ as c}from"./chunks/ArticleMetadata.839094c8.js";import{_ as r,i as d,o as n,c as i,b as s,f as p,t as y,g as u,w as h,e as g,v as F,a as m}from"./app.59cdf3da.js";const E=JSON.parse('{"title":"Function对象","description":"","frontmatter":{"title":"Function对象","author":"Itway","date":"2023/01/09 22:30","categories":["JavaScript知识集"],"tags":["JavaScript基础"]},"headers":[{"level":2,"title":"语法","slug":"语法","link":"#语法","children":[]},{"level":2,"title":"描述","slug":"描述","link":"#描述","children":[]},{"level":2,"title":"构造函数","slug":"构造函数","link":"#构造函数","children":[{"level":3,"title":"属性","slug":"属性","link":"#属性","children":[]}]},{"level":2,"title":"原型对象","slug":"原型对象","link":"#原型对象","children":[]},{"level":2,"title":"示例","slug":"示例","link":"#示例","children":[]}],"relativePath":"courses/javascript/01-javascript基础/09-Function对象.md","lastUpdated":1746545041000}'),A={name:"courses/javascript/01-javascript基础/09-Function对象.md"},x={id:"frontmatter-title",tabindex:"-1"},B=s("a",{class:"header-anchor",href:"#frontmatter-title","aria-hidden":"true"},"#",-1),C=m(`<blockquote><p>示例网站：<a href="https://tsejx.github.io/javascript-guidebook/standard-built-in-objects/fundamental-objects/function/function" target="_blank" rel="noreferrer">https://tsejx.github.io/javascript-guidebook/standard-built-in-objects/fundamental-objects/function/function</a></p></blockquote><p><code>Function</code> 构造函数通过 <code>new</code> 创建一个新的 <code>Function</code> 对象。 在 JavaScript 中，每个函数实际上都是一个 <code>Function</code> 对象。</p><h2 id="语法" tabindex="-1">语法 <a class="header-anchor" href="#语法" aria-hidden="true">#</a></h2><p><strong>构造函数</strong></p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki vp-code-dark"><code><span class="line"><span style="color:#C678DD;">new</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">Function</span><span style="color:#ABB2BF;"> ( [ </span><span style="color:#E06C75;">argName1</span><span style="color:#ABB2BF;"> [, </span><span style="color:#E06C75;">argName1</span><span style="color:#ABB2BF;"> [, </span><span style="color:#E06C75;">argNameN</span><span style="color:#ABB2BF;">... [, </span><span style="color:#E06C75;">funcBody</span><span style="color:#ABB2BF;"> ]]]] )</span></span>
<span class="line"></span></code></pre><pre class="shiki vp-code-light"><code><span class="line"><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Function</span><span style="color:#A6ACCD;"> ( [ argName1 [</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> argName1 [</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> argNameN</span><span style="color:#89DDFF;">...</span><span style="color:#A6ACCD;"> [</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> funcBody ]]]] )</span></span>
<span class="line"></span></code></pre></div><p><strong>函数类型转换函数</strong></p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki vp-code-dark"><code><span class="line"><span style="color:#61AFEF;">Function</span><span style="color:#ABB2BF;"> ( [ </span><span style="color:#E06C75;">argName1</span><span style="color:#ABB2BF;"> [, </span><span style="color:#E06C75;">argName1</span><span style="color:#ABB2BF;"> [, </span><span style="color:#E06C75;">argNameN</span><span style="color:#ABB2BF;">... [, </span><span style="color:#E06C75;">funcBody</span><span style="color:#ABB2BF;"> ]]]] )</span></span>
<span class="line"></span></code></pre><pre class="shiki vp-code-light"><code><span class="line"><span style="color:#82AAFF;">Function</span><span style="color:#A6ACCD;"> ( [ argName1 [</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> argName1 [</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> argNameN</span><span style="color:#89DDFF;">...</span><span style="color:#A6ACCD;"> [</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> funcBody ]]]] )</span></span>
<span class="line"></span></code></pre></div><table><thead><tr><th style="text-align:center;">参数</th><th style="text-align:center;">说明</th><th>类型</th></tr></thead><tbody><tr><td style="text-align:center;"><code>argName1</code></td><td style="text-align:center;">定义的第 1 个参数的名称</td><td>string</td></tr><tr><td style="text-align:center;"><code>argName2</code></td><td style="text-align:center;">定义的第 2 个参数的名称</td><td>string</td></tr><tr><td style="text-align:center;"><code>argNameN</code></td><td style="text-align:center;">定义的第 N 个参数的名称，可以有任意多个</td><td>string</td></tr><tr><td style="text-align:center;"><code>funcBody</code></td><td style="text-align:center;">定义的函数主体，即函数内部的执行代码，默认为空字符串(&quot;&quot;)</td><td>string</td></tr></tbody></table><p><code>Function()</code> 会把传入的最后一个参数作为函数定义的执行代码，之前的所有参数均依次作为函数定义的参数。</p><p>如果没有指定任何参数，则表示该函数没有定义参数列表，函数的执行代码也为空。 如果只指定了一个参数，则该参数将被视作函数的执行代码。如果你想定义一个参数、执行代码为空，请传入两个参数，第二个参数为空字符串即可：<code>new Function(&quot;argName1&quot;, &quot;&quot;)</code>。 <code>Function()</code> 的返回值是 Function 类型，返回一个函数对象。</p><h2 id="描述" tabindex="-1">描述 <a class="header-anchor" href="#描述" aria-hidden="true">#</a></h2><ul><li>使用 <code>Function</code> 构造器生成的 <code>Function</code> 对象是在函数创建时解析的。这比你使用 函数声明 或者 函数表达式 并在你的代码中调用更为低效，因为使用后者创建的函数是跟其他代码一起解析的</li><li>所有被传递到构造函数中的参数，都将被视为是将被创建函数的参数，并且是相同的标识符名称和传递顺序</li><li>使用 <code>Function</code> 构造器生成的函数，并不会在创建它们的上下文中创建闭包；它们一般在全局作用域中被创建。当运行这些函数的时候，它们只能访问自己的本地变量和全局变量，不能访问 <code>Function</code> 构造器被调用生成的上下文的作用域。这和使用带有函数表达式代码的 <code>eval</code> 不同</li><li>以调用函数的方式调用 <code>Function</code> 的构造函数（而不是用 <code>new</code> 关键字）跟以构造函数来调用是一样的</li></ul><h2 id="构造函数" tabindex="-1">构造函数 <a class="header-anchor" href="#构造函数" aria-hidden="true">#</a></h2><h3 id="属性" tabindex="-1">属性 <a class="header-anchor" href="#属性" aria-hidden="true">#</a></h3><table><thead><tr><th style="text-align:center;">属性</th><th style="text-align:center;">描述</th></tr></thead><tbody><tr><td style="text-align:center;"><code>Function.arguments</code></td><td style="text-align:center;">以数组形式获取传入函数的所有参数。此属性已被 <code>arguments</code> 替代。</td></tr><tr><td style="text-align:center;"><code>Function.caller</code></td><td style="text-align:center;">获取调用函数的具体对象</td></tr><tr><td style="text-align:center;"><code>Function.length</code></td><td style="text-align:center;">获取函数的接收参数个数</td></tr><tr><td style="text-align:center;"><code>Function.name</code></td><td style="text-align:center;">获取函数的名称</td></tr><tr><td style="text-align:center;"><code>Function.displayName</code></td><td style="text-align:center;">获取函数的 display name</td></tr></tbody></table><h2 id="原型对象" tabindex="-1">原型对象 <a class="header-anchor" href="#原型对象" aria-hidden="true">#</a></h2><table><thead><tr><th style="text-align:center;">属性</th><th style="text-align:center;">描述</th></tr></thead><tbody><tr><td style="text-align:center;"><code>Function.prototype.apply</code></td><td style="text-align:center;">设定指定函数的调用上下文环境，并提供数组形式的参数</td></tr><tr><td style="text-align:center;"><code>Function.prototype.call</code></td><td style="text-align:center;">设定指定函数的调用上下文环境，并提供列表形式的参数</td></tr><tr><td style="text-align:center;"><code>Function.prototype.bind</code></td><td style="text-align:center;">绑定指定函数的调用上下文，无论如何调用均以该调用函数上下文为准</td></tr><tr><td style="text-align:center;">⚠️ <code>Function.prototype.isGenerator</code></td><td style="text-align:center;">用于检测函数对象是否为 <code>Generator</code> 生成器函数</td></tr></tbody></table><blockquote><p>说明：<code>call</code>、<code>apply</code>、<code>bind</code>都可以改变函数<code>this</code>指向。</p></blockquote><h2 id="示例" tabindex="-1">示例 <a class="header-anchor" href="#示例" aria-hidden="true">#</a></h2>`,19);function b(t,_,f,D,v,N){const o=c,l=d("ClientOnly");return n(),i("div",null,[s("h1",x,[p(y(t.$frontmatter.title)+" ",1),B]),u(l,null,{default:h(()=>{var e,a;return[(((e=t.$frontmatter)==null?void 0:e.aside)??!0)&&(((a=t.$frontmatter)==null?void 0:a.showArticleMetadata)??!1)?(n(),g(o,{key:0,article:t.$frontmatter},null,8,["article"])):F("",!0)]}),_:1}),C])}const q=r(A,[["render",b]]);export{E as __pageData,q as default};

---
title: Vue3知识笔记
author: Itway
date: 2022/12/28 15:00
categories:
 - Vue知识集
tags:
 - Vue
---

# Vue3知识笔记

## vue 基本指定

### 基本指令

- **v-once**：用于指定元素或者组件只渲染一次。当数据发生变化时，元素或者组件以及其所有的子元素将视为静态内容并且跳过；该指令可以用于性能优化。
- **v-text**：等价于{{}}。
- **v-html**：解析 html 内容。
- **v-pre**：用于跳过元素和它的子元素的编译过程，显示原始的 Mustache ({{}})标签。

### 常用

- **v-bind：**绑定属性

  - 语法糖：**：**
  - 用法：v-bind:src=“src”，动态地绑定一个或多个 attribute，或一个组件 prop 到表达式。
  - 绑定 class、style：对象语法、数组语法。
  - 动态绑定属性：**_:[name] = "value"_**。
  - 绑定一个对象：**v-bind** = "对象"。⭐

- **v-on：**绑定事件

  - 语法糖：@
  - 用法：v-on:click="btnClick"。绑定多个事件可以传入一个对象（v-on=“{click：btnclick，mosuemove：mouseMove}”）。
  - 参数传递：如果需要同时传入某个参数，同时需要 event 时，可以通过$event 传入事件。
  - 修饰符：.stop，.prevent.....

- **v-show：**

  - 不支持 template。
  - v-show 元素无论是否需要显示到浏览器上，它的 DOM 实际都是有渲染的，只是通过 CSS 的 display 属性来进行切换。
  - 如果我们的原生需要在显示和隐藏之间频繁的切换，那么使用 v-show。

- **v-if：**

  - 支持 template
  - v-if 当条件为 false 时，其对应的原生压根不会被渲染到 DOM 中。
  - p 如果不会频繁的发生切换，那么使用 v-if。

- **v-for：**遍历数组、对象

  - 参数："(value, key, index)  in/of object。
  - v-for 中的**key**：

    - key 属性主要用在 Vue 的**虚拟 DOM 算法**，在**新旧 nodes**对比时辨识**VNodes**；
    - 如果**不使用 key**，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试**就地修改/复用相同类型元素**的算法；
    - 而**使用 key**时，它会基于 key 的变化**重新排列元素顺序**，并且会**移除/销毁 key**不存在的元素；
    - **VNode**：虚拟节点，无论是组件还是元素，它们最终在 Vue 中表示出来的都是一个个 VNode，本质是一个 JavaScript 的对象。最大好处：**跨平台**。
    - 虚拟 DOM

- **v-model**：双向数据绑定

```html
<input v-model="searchText"/>
等价于
<input :value="searchText" @input="searchText=$event.target.value" />
```

- v-model 本质上不过是**语法糖**，它负责**监听用户的输入**事件来**更新数据**。

- **修饰符**：

  - **.lazy**：会将绑定的事件切换为 change 事件，只有在提交时才会触发。
  - **.number：**转换为数字类型。只会获取可以转换为数字的部分。比如：”111aaa11“ 转换为 111。
  - **.trim：**自动过滤用户输入的守卫空白字符。

## computed 和 watch

### 计算属性：computed

- 用于对 data 中的数据进行复杂逻辑处理，比如：合并名字。
- 计算属性将被混入到组件实例中。所有 getter 和 setter 的 this 上下文自动地绑定为组件实例。
- 计算属性有缓存，只有在依赖的数据发生变化时计算属性会重新计算。
- 是一个键值对

### 侦听器：watch

- 用于侦听数据进行一些代码逻辑处理，比如：请求网络。
- deep：进行深层侦听；immediate：候无论数据是否有变化，侦听的函数都会执行一次。
- this.$watch(data，callback，option)，在生命周期中使用该方法侦听。它返回一个取消侦听函数，用来停止触发回调。
- 当变更（不是替换）对象或数组并使用 deep 选项时，旧值将与新值相同，因为它们的引用指向同一个对象/数组。
- 如果要监听数组里面对象某个属性，可以使用**deep**监听或者**使用子组件在子组件监听**。

## diff 算法

### vue 源码对于 key 的判断：

- 如果有 key，执行 patchKeyedChildren。
- 如果没有 key，执行 patchUnkeyedChildren。

### diff 算法 ：

**有 key 情况，分五部：**

1. 从头部开始遍历，相同就 patch 继续遍历，节点不同跳出循环。
2. 从尾部开始遍历，相同就 patch 继续遍历，节点不同跳出循环。
3. 如果旧节点遍历完，依旧有新节点，那么新节点就挂载。（patch 方法第一个参数为**null**就挂载，第一个参数为 n1 就更新。）
4. 如果新节点遍历完，还有旧节点，那么就把旧节点卸载。
5. 如果中间是不知道如何排列位置的节点序列，那么会根据 key 建立 map 索引图，最大限度的使用旧节点。

**无 key 情况：**

1. 获取新旧节点的长度。
2. 获取新旧节点中最小的长度。
3. 根据获取的最小长度，从 0 位置开始依次进行 patch 比较。
4. 如果旧节点数大于新节点数，卸载多余节点；否则就挂载新的节点。

## 全局（局部）组件

### 注册组件：

#### 注册全局组件

- 通过 app.component(name，object)传入组件名称、组件对象即可注册一个全局组件。

```html
<div id="app"></div>

<template id="my-app">
  <component-a></component-a>
  <component-b></component-b>

  <!-- <component-c></component-c> -->
  <!-- <ComponentName></ComponentName> -->
  <component-name></component-name>
</template>

<template id="component-a">
  <h2>{{title}}</h2>
  <p>{{desc}}</p>
  <button @click="btnClick">按钮点击</button>
</template>

<template id="component-b">
  <div>
    <input type="text" v-model="message" />
    <h2>{{message}}</h2>
  </div>
</template>

<template id="component-c">
  <h2>ComponentC</h2>
</template>

<script src="../js/vue.js"></script>
<script>
  const App = {
    template: "#my-app",
  };

  const app = Vue.createApp(App);

  // 使用app注册一个全局组件app.component()
  // 全局组件: 意味着注册的这个组件可以在任何的组件模板中使用
  app.component("component-a", {
    template: "#component-a",
    data() {
      return {
        title: "我是标题",
        desc: "我是内容, 哈哈哈哈哈",
      };
    },
    methods: {
      btnClick() {
        console.log("按钮的点击");
      },
    },
  });

  app.component("component-b", {
    template: "#component-b",
    data() {
      return {
        message: "Hello World",
      };
    },
  });

  app.component("ComponentName", {
    template: "#component-c",
  });

  app.mount("#app");
</script>
```

#### 注册局部组件

- 通过 components 属性选项来进行注册，该 components 选项对应的是一个对象，对象中的键值对是 组件的名称: 组件对象。

```html
<body>
  <div id="app"></div>

  <template id="my-app">
    <h2>{{message}}</h2>
    <component-a></component-a>
  </template>

  <template id="component-a">
    <h2>我是组件A</h2>
    <p>我是内容, 哈哈哈哈</p>
  </template>
  <script src="../js/vue.js"></script>
  <script
    const ComponentA = {
      template: "#component-a"
    }

    const App = {
      template: '#my-app',
      components: {
        // key: 组件名称
        // value: 组件对象
        ComponentA: ComponentA
      },
      data() {
        return {
          message: "Hello World"
        }
      }
    }

    const app = Vue.createApp(App);
    // app.component("ComponentA", ComponentA);
    app.mount('#app');
  </script>
</body>
```

### 组件命名：

- 方式一：使用 kebab-case（短横线分割符）。
- 方式二：使用 PascalCase（驼峰标识符）。

## 组件通信

### 父子组件之间通信的方式：

- 父组件传递给子组件：通过**props 属性**；
- 子组件传递给父组件：通过**$emit 触发事件**；

#### 父组件传递给子组件：

**什么是 Props 呢？**

- Props 是你可以在组件上注册一些**自定义的 attribute**；
- 父组件给这些 attribute 赋值，子组件**通过 attribute 的名称获取到对应的值**；

**Props 有两种常见的用法：**

- 方式一：**字符串数组**，数组中的字符串就是 attribute 的名称；
- 方式二：**对象类型**，对象类型我们可以在指定 attribute 名称的同时，指定它需要传递的类型、是否是必须的、 默认值等等；

#### 子组件传递给父组件：

**什么情况下子组件需要传递内容到父组件呢？**

- 当子组件有一些事件发生的时候，比如在组件中发生了点击，父组件需要切换内容；
- 子组件有一些内容想要传递给父组件的时候；

**我们如何完成上面的操作呢？**

- 首先，我们需要在子组件中定义好在某些情况下触发的事件名称；

- 其次，在父组件中以 v-on 的方式传入要监听的事件名称，并且绑定到对应的方法中；

- 最后，在子组件中发生某个事件的时候，根据事件名称触发对应的事件；

```vue
// app.vue
<template>
  <div>
    <tab-control :titles="titles" @titleClick="titleClick"></tab-control>
    <h2>{{ contents[currentIndex] }}</h2>
  </div>
</template>

<script>
import TabControl from "./TabControl.vue";

export default {
  components: {
    TabControl,
  },
  data() {
    return {
      titles: ["衣服", "鞋子", "裤子"],
      contents: ["衣服页面", "鞋子页面", "裤子页面"],
      currentIndex: 0,
    };
  },
  methods: {
    titleClick(index) {
      this.currentIndex = index;
    },
  },
};
</script>

// TabControl.vue
<template>
  <div class="tab-control">
    <div
      class="tab-control-item"
      :class="{ active: currentIndex === index }"
      v-for="(title, index) in titles"
      :key="title"
      @click="itemClick(index)"
    >
      <span>{{ title }}</span>
    </div>
  </div>
</template>

<script>
export default {
  emits: ["titleClick"],
  props: {
    titles: {
      type: Array,
      default() {
        return [];
      },
    },
  },
  data() {
    return {
      currentIndex: 0,
    };
  },
  methods: {
    itemClick(index) {
      this.currentIndex = index;
      this.$emit("titleClick", index);
    },
  },
};
</script>
```

### 非父子组件的通信：

- Provide/Inject；

- Mitt 全局事件总线（**eventBus**）；

#### Provide 和 Inject：

- 用于非父子组件之间共享数据。
- provide 要想响应式，可以使用 vue3 新特性 computed 函数，返回一个 ref 对象。

```vue
// App.vue
<template>
  <div>
    <home></home>
    <button @click="addName">+name</button>
  </div>
</template>
<script>
import Home from "./Home.vue";
import { computed } from "vue";
export default {
  components: {
    Home,
  },
  provide() {
    return {
      name: "why",
      age: 18,
      length: computed(() => this.names.length), // ref对象 .value
    };
  },
  data() {
    return {
      names: ["abc", "cba", "nba"],
    };
  },
  methods: {
    addName() {
      this.names.push("why");
    },
  },
};
</script>

// Home.vue
<template>
  <div>
    <home-content></home-content>
  </div>
</template>
<script>
import HomeContent from "./HomeContent.vue";
export default {
  components: {
    HomeContent,
  },
};
</script>

// HomeContent.vue
<template>
  <div>HomeContent: {{ name }} - {{ age }} - {{ length.value }}</div>
</template>
<script>
export default {
  inject: ["name", "age", "length"],
};
</script>
```

#### 全局事件总线 mitt 库:

- npm install mitt；
- 封装一个工具 eventbus.js；

```javascript
// eventbus.js
import mitt from "mitt";

const emitter = mitt();
// export const emitter1 = mitt();
// export const emitter2 = mitt();
// export const emitter3 = mitt();

export default emitter;
```

**监听事件**：

```vue
<script>
import emitter from "./utils/eventbus";
export default {
  created() {
    emitter.on("why", (info) => {
      console.log("why:", info);
    });

    emitter.on("kobe", (info) => {
      console.log("kobe:", info);
    });

    emitter.on("*", (type, info) => {
      console.log("* listener:", type, info);
    });
  },
};
</script>
```

**触发事件：**

```vue
<template>
  <div>
    <button @click="btnClick">按钮点击</button>
  </div>
</template>
<script>
import emitter from "./utils/eventbus";
export default {
  methods: {
    btnClick() {
      console.log("about按钮的点击");
      emitter.emit("why", { name: "why", age: 18 });
      // emitter.emit("kobe", {name: "kobe", age: 30});
    },
  },
};
</script>
```

**取消监听：**

```javascript
// 取消emitter中所有的监听
emitter.all.clear();

// 定义一个函数
function onFoo() {}
emitter.on("foo", onfoo); // 监听
emitter.off("foo", onfoo); // 取消监听
```

## 插槽 slot

插槽基本使用：

```vue
<template>
  <div>
    <slot>
      <i>我是默认的i元素</i>
    </slot>
  </div>
</template>

<template>
  <div>
    <my-slot-cpn>
      <button>我是按钮</button>
    </my-slot-cpn>
  </div>
</template>
```

#### 具名插槽：

- 具名插槽顾名思义就是给插槽起一个名字， 元素有一个特殊的 attribute：**name**；
- 一个不带 name 的 slot，会带有隐含的名字 **default**；
- 可以使用缩写**#**代替**v-slot:**（#left = v-slot:left）；
- **动态插槽名：**通过**v-slot:[name]**方式动态绑定一个插槽名；

```vue
// app.vue
<template>
  <div>
    <nav-bar :name="name">
      <template #left>
        <button>左边的按钮</button>
      </template>
      <template #center>
        <h2>我是标题</h2>
      </template>
      <template #right>
        <i>右边的i元素</i>
      </template>
      <template #[name]>
        <i>why内容</i>
      </template>
    </nav-bar>
  </div>
</template>

<script>
import NavBar from "./NavBar.vue";

export default {
  components: {
    NavBar,
  },
  data() {
    return {
      name: "why",
    };
  },
};
</script>

// navbar.vue
<template>
  <div class="nav-bar">
    <!-- <slot name="default"></slot> -->
    <div class="left">
      <slot name="left"></slot>
    </div>
    <div class="center">
      <slot name="center"></slot>
    </div>
    <div class="right">
      <slot name="right"></slot>
    </div>
    <div class="addition">
      <slot :name="name"></slot>
    </div>
  </div>
</template>

<script>
export default {
  props: {
    name: String,
  },
};
</script>
```

#### 作用域插槽：

先了解 vue 中渲染作用域的概念：

- 父级模板里的所有内容都是在父级作用域中编译的；
- 子模板里的所有内容都是在子作用域中编译的；

有时候我们希望插槽可以访问到子组件中的内容是非常重要的：

- 当一个组件被用来渲染一个**数组元素**时，我们**使用插槽**，并且希望插槽中显示每项的内容；
- 这个 Vue 给我们提供了作用域插槽

**独占默认插槽的缩写**：

- 如果我们的插槽是默认插槽 default，那么在使用的时候 v-slot:default="slotProps"可以简写为 v-slot="slotProps"：
- 并且如果我们的插槽只有默认插槽时，组件的标签可以被当做插槽的模板来使用，这样，我们就可以将 v-slot 直 接用在组件上：

```vue
<template>
  <div>
    <show-names :names="names">
      <template v-slot="slotProps">
        <strong>{{ slotProps.item }}-{{ slotProps.index }}</strong>
      </template>
    </show-names>

    <show-names :names="names" v-slot="coderwhy">
      <button>{{ coderwhy.item }}-{{ coderwhy.index }}</button>
    </show-names>

    <!-- 默认插槽和具名插槽混合 -->
    <!-- 注意: 如果还有其他的具名插槽, 那么默认插槽也必须使用template来编写 -->
    <show-names :names="names">
      <template v-slot="coderwhy">
        <button>{{ coderwhy.item }}-{{ coderwhy.index }}</button>
      </template>

      <template v-slot:why>
        <h2>我是why的插入内容</h2>
      </template>
    </show-names>
  </div>
</template>
```

## 动态组件

动态组件是使用 **component** 组件，通过一个特殊的 attribute **is** 来实现：

```vue
<component :is="currentTab" name="coderwhy" :age="18" @pageClick="pageClick">
      </component>
```

这个**currentTab**的值需要是什么内容呢？

- 可以是通过**component 函数注册的组件**；
- 也可以是在一个组件对象的**components 对象中注册的组件**；

## keep-alive

在开发中某些情况我们希望**继续保持组件的状态，而不是销毁掉**，这个时候我们就可以使用一个内置组件： **keep-alive**。

```vue
<keep-alive include="home,about">
    <component :is="currentTab"
               name="coderwhy"
               :age="18"
               @pageClick="pageClick">
    </component>
</keep-alive>
```

#### keep-alive 属性：

- **include** - string | RegExp | Array。只有名称匹配的组件会被缓 存；
- **exclude** - string | RegExp | Array。任何名称匹配的组件都不会被缓存；
- **max** - number | string。最多可以缓存多少组件实例，一旦达 到这个数字，那么缓存组件中最近没有被访问的实例会被销毁；

#### 缓存组件的生命周期：

对于缓存的组件来说，再次进入时，我们是不会执行 created 或者 mounted 等生命周期函数的：

- 但是有时候我们确实希望监听到何时重新进入到了组件，何时离开了组件；
- 这个时候我们可以使用**activated** 和 **deactivated** 这两个生命周期钩子函数来监听；

```vue
<script>
export default {
  name: "about",
  data() {
    return {
      counter: 0,
    };
  },
  created() {
    console.log("about created");
  },
  unmounted() {
    console.log("about unmounted");
  },
  activated() {
    console.log("about activated");
  },
  deactivated() {
    console.log("about deactivated");
  },
};
</script>
```

## 异步组件

#### Webpack 的代码分包：

- 默认的打包过程：

  - 默认情况下，在构建整个组件树的过程中，因为组件和组件之间是通过模块化直接依赖的，那么 webpack 在打包时就会将组 件模块打包到一起（比如一个 app.js 文件中）；
  - 这个时候随着项目的不断庞大，app.js 文件的内容过大，会造成首屏的渲染速度变慢；

- 打包时，代码的分包：

  - 所以，对于一些不需要立即使用的组件，我们可以单独对它们进行拆分，拆分成一些小的代码块 chunk.js；
  - 这些 chunk.js 会在需要时从服务器加载下来，并且运行代码，显示对应的内容；

- 那么 webpack 中如何可以对代码进行分包呢？

```javascript
// 通过import函数导入的模块, 后续webpack对其进行打包的时候就会进行分包的操作
// import("./12_异步组件的使用/utils/math").then((res) => {
//   console.log(res.sum(20, 30))
// })
```

#### Vue 中的异步组件：

- 如果我们的项目过大了，对于某些组件我们希望**通过异步的方式来进行加载**（目的是可以对其进行分包处理），那 么 Vue 中给我们提供了一个函数：**defineAsyncComponent**。

- **defineAsyncComponent 接受两种类型的参数：**

  - 类型一：工厂函数，该工厂函数需要返回一个 Promise 对象；
  - 类型二：接受一个对象类型，对异步函数进行配置；

- **工厂函数类型一的写法：**
```vue
<script>
import { defineAsyncComponent } from "vue";
const AsyncCategory = defineAsyncComponent(() => import("./AsyncCategory.vue"));

export default {
  components: {
    AsyncCategory,
  },
};
</script>
```

- 写法二：
```vue
<script>
const AsyncCategory = defineAsyncComponent({
  loader: () => import("./AsyncCategory.vue"),
  loadingComponent: Loading,
  // errorComponent,
  // 在显示loadingComponent组件之前, 等待多长时间
  delay: 2000,
  /**
   * err: 错误信息,
   * retry: 函数, 调用retry尝试重新加载
   * attempts: 记录尝试的次数
   */
  onError: function (err, retry, attempts) {},
});
</script>
```

### 异步组件和 Suspense：

Suspense 是一个内置的全局组件，**实验性特性**，该组件有两个插槽：

- **default**：如果 default 可以显示，那么显示 default 的内容；
- **fallback**：如果 default 无法显示，那么会显示 fallback 插槽的内容；

```vue
<template>
  <div>
    <suspense>
      <template #default>
        <async-category></async-category>
      </template>
      <template #fallback>
        <loading></loading>
      </template>
    </suspense>
  </div>
</template>
```

## 组件的 v-model

#### 组件的 v-model：

- 前面我们在 input 中可以使用 v-model 来完成双向绑定：

  - 这个时候往往会非常方便，因为 v-model 默认帮助我们完成了两件事；

  - v-bind:value 的数据绑定和@input 的事件监听；
```vue
<input v-model="message">
<!-- 相当于 -->
<input :value="message" @input="message = $event.target.value">
```

- 如果我们现在封装了一个组件，其他地方在使用这个组件时，是否也可以使用 v-model 来同时完成这两个功能呢？

  - 也是可以的，vue 也支持在组件上使用 v-model；

- 当我们在组件上使用的时候，等价于如下的操作：

  - 我们会发现和 input 元素不同的只是属性的名称和事件触发的名称而已；

```vue
<hy-input v-model="message"></hy-input>
<!-- 相当于 -->
<hy-input
  :modelValue="message"
  @update:model-value="message = $event"
></hy-input>
```

#### 组件 v-model 的实现:

那么，为了我们的 MyInput 组件可以正常的工作，这个组件内的   必须：

- 将其 value attribute 绑定到一个名叫 modelValue 的 prop 上；

- 在其 input 事件被触发时，将新的值通过自定义的 update:modelValue 事件抛出；

- 我们可以使用计算属性的 setter 和 getter 来完成数据双向绑定；

```vue
<template>
  <div>
    <!-- 1.默认绑定和事件处理 -->
    <!-- <button @click="btnClick">hyinput按钮</button>
    <h2>HyInput的message: {{modelValue}}</h2> -->

    <!-- 2.通过input -->
    <!-- <input :value="modelValue" @input="btnClick"> -->

    <!-- 3.绑定到props中是不对的 -->
    <!-- <input v-model="modelValue"> -->

    <!-- 4. -->
    <input v-model="value" />
  </div>
</template>

<script>
export default {
  props: {
    modelValue: String,
  },
  emits: ["update:modelValue"],
  computed: {
    value: {
      set(value) {
        this.$emit("update:modelValue", value);
      },
      get() {
        return this.modelValue;
      },
    },
  },
  methods: {
    btnClick(event) {
      this.$emit("update:modelValue", event.target.value);
    },
  },
};
</script>
```

#### 绑定多个属性：

我们现在通过 v-model 是直接绑定了一个属性，如果我们希望绑定多个属性呢？

- 默认情况下的 v-model 其实是**绑定了 modelValue 属性**和 **@update:modelValue 的事件**；

- 如果我们希望绑定更多，可以**给 v-model 传入一个参数**，那么这个**参数的名称就是我们绑定属性的名称**；


```vue
// App.vue
<template>
  <div>
    <!-- 绑定两个v-model -->
    <hy-input v-model="message" v-model:title="title"></hy-input>

    <h2>{{ message }}</h2>
    <h2>{{ title }}</h2>
  </div>
</template>
<script>
import HyInput from "./HyInput.vue";
export default {
  components: {
    HyInput,
  },
  data() {
    return {
      message: "Hello World",
      title: "哈哈哈",
    };
  },
};
</script>

// Hyinput.vue
<template>
  <div>
    <input v-model="value" />
    <input v-model="why" />
  </div>
</template>
<script>
export default {
  props: {
    modelValue: String,
    title: String,
  },
  emits: ["update:modelValue", "update:title"],
  computed: {
    value: {
      set(value) {
        this.$emit("update:modelValue", value);
      },
      get() {
        return this.modelValue;
      },
    },
    why: {
      set(why) {
        this.$emit("update:title", why);
      },
      get() {
        return this.title;
      },
    },
  },
};
</script>
```

## 动画/过渡

#### Vue 的 transition 动画：

vue 提供了 transition 的封装组件；

```vue
<template>
  <div>
    <button @click="isShow = !isShow">显示/隐藏</button>

    <transition name="why">
      <h2 v-if="isShow">Hello World</h2>
    </transition>
  </div>
</template>

<script>
export default {
  data() {
    return {
      isShow: true,
    };
  },
};
</script>

<style scoped>
.why-enter-from,
.why-leave-to {
  opacity: 0;
}

.why-enter-to,
.why-leave-from {
  opacity: 1;
}

.why-enter-active,
.why-leave-active {
  transition: opacity 2s ease;
}
</style>
```

**Transition 组件的原理：**

当插入或删除包含在 transition 组件中的元素时，Vue 将会做以下处理：

1. 自动嗅探**目标元素是否应用了 CSS 过渡或者动画**，如果有，那么**在恰当的时机添加/删除 CSS 类名**；
2. 如果 transition 组件提供了**JavaScript 钩子函数**，这些钩子函数将在恰当的时机被调用；
3. 如果**没有找到 JavaScript 钩子并且也没有检测到 CSS 过渡/动画，DOM 插入、删除操作将会立即执行**；

#### 过渡动画 class:

- **v-enter-from**：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。
- **v-enter-active**：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动 画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。
- **v-enter-to**：定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter-from 被移除)，在过渡/ 动画完成之后移除。
- **v-leave-from**：定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。
- **v-leave-active**：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在 过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。
- **v-leave-to**：离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave-from 被删除)，在过渡/ 动画完成之后移除。

**class 的 name 命名规则如下**：

- 如果我们使用的是一个**没有 name 的 transition**，那么所有的 class 是以 **v- 作为默认前缀；**
- 如果我们添加了一个 name 属性，比如 ，那么所有的 class 会以 why- 开头；

#### 过渡 css 动画

前面我们是通过**transition**来实现的动画效果，另外我们也可以通过**animation**来实现。

```vue
<template>
  <div class="app">
    <div><button @click="isShow = !isShow">显示/隐藏</button></div>

    <transition name="why">
      <h2 class="title" v-if="isShow">Hello World</h2>
    </transition>
  </div>
</template>

<script>
export default {
  data() {
    return {
      isShow: true,
    };
  },
};
</script>

<style scoped>
.app {
  width: 200px;
  margin: 0 auto;
}

.title {
  display: inline-block;
}

.why-enter-active {
  animation: bounce 1s ease;
}

.why-leave-active {
  animation: bounce 1s ease reverse;
}

@keyframes bounce {
  0% {
    transform: scale(0);
  }
  50% {
    transform: scale(1.2);
  }
  100% {
    transform: scale(1);
  }
}
</style>
```

#### type 和 duration 属性：

**type：**

- 如果我们只是使用了其中的一个，那么 Vue 能自动识别类型并设置监听；
- 如果同时设置了过渡和动画，可能某一个动画执行结束时，另外一个动画还没有结束；
- 可以设置 type 属性为 animation 或者 transition 来明确的告知 Vue 监听的类型

**duration：**可以显示的来指定过渡的时间

- number 类型：同时设置进入和离开的过渡时间；
- object 类型：分别设置进入和离开的过渡时间；

```vue
<template>
  <div class="app">
    <div><button @click="isShow = !isShow">显示/隐藏</button></div>

    <transition
      name="why"
      type="transition"
      :duration="{ enter: 800, leave: 1000 }"
    >
      <h2 class="title" v-if="isShow">Hello World</h2>
    </transition>
  </div>
</template>
```

#### 过渡的模式 mode:

当两个元素进行切换或者动态组件切换的时候，进入和离开动画是同时发生的；

如果我们不希望同时执行进入和离开动画，那么我们需要设置 transition 的过渡模式：

- **in-out**: 新元素先进行过渡，完成之后当前元素过渡离开；
- **out-in**: 当前元素先进行过渡，完成之后新元素过渡进入；

```vue
<template>
  <div class="app">
    <div><button @click="isShow = !isShow">显示/隐藏</button></div>

    <transition name="why" mode="out-in">
      <h2 class="title" v-if="isShow">Hello World</h2>
      <h2 class="title" v-else>你好啊,李银河</h2>
    </transition>
  </div>
</template>
```

#### appear 初次渲染：

默认情况下，**首次渲染的时候是没有动画的**，如果我们希望给他添加上去动画，那么就可以**增加另外一个属性 appear**

#### 自定义过渡 class：

- 我们可以**通过以下 attribute 来自定义过渡类名**：

  - enter-from-class
  - enter-active-class
  - enter-to-class
  - leave-from-class
  - leave-active-class
  - leave-to-class

- 他们的**优先级高于普通的类名**，这对于 Vue 的过渡系统和其他第三方 CSS 动画库，如 **Animate.css 结合使用**十分有用。

#### JavaScript 钩子：

transition 组件给我们提供的 JavaScript 钩子，这些钩子可以帮助我们监听动画执行到什么阶段了。

- 当我们使用 JavaScript 来执行过渡动画时，需要进行 **done 回调**，否则它们将会被同步调用，过渡会立即完成。
- 添加 **:css="false"**，也会让 Vue 会**跳过 CSS 的检测**，除了性能略高之外，这**可以避免过渡过程中 CSS 规则的影响**。

```vue
<template>
  <div class="app">
    <div><button @click="isShow = !isShow">显示/隐藏</button></div>

    <transition
      @before-enter="beforeEnter"
      @enter="enter"
      @after-enter="afterEnter"
      @before-leave="beforeLeave"
      @leave="leave"
      @afterLeave="afterLeave"
      :css="false"
    >
      <h2 class="title" v-if="isShow">Hello World</h2>
    </transition>
  </div>
</template>

<script>
export default {
  data() {
    return {
      isShow: true,
    };
  },
  methods: {
    beforeEnter() {
      console.log("beforeEnter");
    },
    enter(el, done) {
      console.log("enter");
      done();
    },
    afterEnter() {
      console.log("afterEnter");
    },
    beforeLeave() {
      console.log("beforeLeave");
    },
    leave(el, done) {
      console.log("leave");
      done();
    },
    afterLeave() {
      console.log("afterLeave");
    },
  },
};
</script>

<style scoped>
.title {
  display: inline-block;
}
</style>
```

#### 认识 gsap 库：

某些情况下我们希望**通过 JavaScript 来实现一些动画的效果**，这个时候我们可以选择使用**gsap 库**来完成。

```vue
<template>
  <div class="app">
    <div><button @click="isShow = !isShow">显示/隐藏</button></div>

    <transition @enter="enter" @leave="leave" :css="false">
      <h2 class="title" v-if="isShow">Hello World</h2>
    </transition>
  </div>
</template>

<script>
import gsap from "gsap";

export default {
  data() {
    return {
      isShow: true,
    };
  },
  methods: {
    enter(el, done) {
      console.log("enter");
      gsap.from(el, {
        scale: 0,
        x: 200,
        onComplete: done,
      });
    },
    leave(el, done) {
      console.log("leave");
      gsap.to(el, {
        scale: 0,
        x: 200,
        onComplete: done,
      });
    },
  },
};
</script>

<style scoped>
.title {
  display: inline-block;
}
</style>
```

#### 列表动画：

使用  transition-group 组件来完成；

使用 transition-group 有如下的特点：

- 默认情况下，它不会渲染一个元素的包裹器，但是你可以**指定一个元素并以 tag attribute 进行渲染**；
- 过渡模式不可用，因为我们不再相互切换特有的元素；
- 内部元素总是需要提供**唯一的 key attribute 值**；
- CSS 过渡的类将会应用在内部的元素中，而**不是这个组/容器本身**；

虽然新增的或者删除的节点是有动画的，但是对于哪些其他需要移动的节点是没有动画的：

- 我们可以通过使用一个新增的 **v-move** 的 class 来完成动画；
- 它会在元素改变位置的过程中应用；
- 像之前的名字一样，我们可以通过 name 来自定义前缀；

```vue
<template>
  <div>
    <button @click="addNum">添加数字</button>
    <button @click="removeNum">删除数字</button>
    <button @click="shuffleNum">数字洗牌</button>

    <transition-group tag="p" name="why">
      <span v-for="item in numbers" :key="item" class="item">
        {{ item }}
      </span>
    </transition-group>
  </div>
</template>

<script>
import _ from "lodash";

export default {
  data() {
    return {
      numbers: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
      numCounter: 10,
    };
  },
  methods: {
    addNum() {
      this.numbers.splice(this.randomIndex(), 0, this.numCounter++);
    },
    removeNum() {
      this.numbers.splice(this.randomIndex(), 1);
    },
    shuffleNum() {
      this.numbers = _.shuffle(this.numbers);
    },
    randomIndex() {
      return Math.floor(Math.random() * this.numbers.length);
    },
  },
};
</script>

<style scoped>
.item {
  margin-right: 10px;
  display: inline-block;
}

.why-enter-from,
.why-leave-to {
  opacity: 0;
  transform: translateY(30px);
}

.why-enter-active,
.why-leave-active {
  transition: all 1s ease;
}

.why-leave-active {
  position: absolute;
}

.why-move {
  transition: transform 1s ease;
}
</style>
```

**列表交错过渡**：

```vue
<template>
  <div>
    <input v-model="keyword" />
    <transition-group
      tag="ul"
      name="why"
      :css="false"
      @before-enter="beforeEnter"
      @enter="enter"
      @leave="leave"
    >
      <li v-for="(item, index) in showNames" :key="item" :data-index="index">
        {{ item }}
      </li>
    </transition-group>
  </div>
</template>

<script>
import gsap from "gsap";

export default {
  data() {
    return {
      names: ["abc", "cba", "nba", "why", "lilei", "hmm", "kobe", "james"],
      keyword: "",
    };
  },
  computed: {
    showNames() {
      return this.names.filter((item) => item.indexOf(this.keyword) !== -1);
    },
  },
  methods: {
    beforeEnter(el) {
      el.style.opacity = 0;
      el.style.height = 0;
    },
    enter(el, done) {
      gsap.to(el, {
        opacity: 1,
        height: "1.5em",
        delay: el.dataset.index * 0.5,
        onComplete: done,
      });
    },
    leave(el, done) {
      gsap.to(el, {
        opacity: 0,
        height: 0,
        delay: el.dataset.index * 0.5,
        onComplete: done,
      });
    },
  },
};
</script>

<style scoped>
/* .why-enter-from,
  .why-leave-to {
    opacity: 0;
  }

  .why-enter-active,
  .why-leave-active {
    transition: opacity 1s ease;
  } */
</style>
```

## Mixin

在 Vue2 和 Vue3 中都支持的一种方式就是使用 Mixin 来完成：

- Mixin 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能；
- 一个 Mixin 对象可以包含任何组件选项；
- 当组件使用 Mixin 对象时，所有 Mixin 对象的选项将被 混合 进入该组件本身的选项中；

**基本使用：**

```vue
// App.vue
<template>
  <div>
    <h2>{{ message }}</h2>
    <button @click="foo">按钮</button>
  </div>
</template>
<script>
import { demoMixin } from "./mixins/demoMixin";

export default {
  mixins: [demoMixin],
  data() {
    return {
      title: "Hello World",
    };
  },
};
</script>
```

```javascript
// domeMixin.js
export const demoMixin = {
  data() {
    return {
      message: "Hello DemoMixin",
    };
  },
  methods: {
    foo() {
      console.log("demo mixin foo");
    },
  },
  created() {
    console.log("执行了demo mixin created");
  },
};
```

#### Mixin 的合并规则:

- 如果 Mixin 对象中的选项和组件对象中的选项发生了冲突，那么 Vue 会如何操作呢？

  - 这里**分成不同的情况**来进行处理；

- 情况一：如果是 data 函数的返回值对象

  - 返回值对象默认情况下会**进行合并**；
  - 如果 data 返回值对象的属性发生了冲突，那么会**保留组件自身的数据**；

- 情况二：如何生命周期钩子函数

  - 生命周期的钩子函数会被**合并到数组中，都会被调用**；

- 情况三：值为对象的选项，例如 methods、components 和 directives，将被合并为同一个对象。

  - 比如都有**methods 选项**，并且都定义了方法，那么它们**都会生效**；
  - 但是如果**对象的 key 相同**，那么**会取组件对象的键值对**；

#### 全局混入 Mixin:

全局的 Mixin 可以使用 **应用 app 的方法 mixin** 来完成注册；

```javascript
/
app.mixin({
  data() {
    return {}
  },
  methods: {

  },
  created() {
    console.log("全局的created生命周期");
  }
});
```

#### extends：

允许声明扩展另外一个组件，**类似于 Mixins**；

在开发中 extends 用的非常少，在 Vue2 中比较推荐大家使用 Mixin，而在 Vue3 中推荐使用 Composition API。

## composition API

#### Options API 的弊端：

- 当我们实现某一个功能时，这个功能对应的代码逻辑会被拆分到各个属性中；
- 当我们组件变得更大、更复杂时，逻辑关注点的列表就会增长，那么同一个功能的逻辑就会被拆分的很分散；
- 尤其对于那些一开始没有编写这些组件的人来说，这个组件的代码是难以阅读和理解的（阅读组件的其他人）；
- 当我们处理单个逻辑关注点时，需要不断的跳到相应的代码块中；

#### 认识 Composition API：

- 将同一个逻辑关注点相关的代码收集在一起；
- 在 Vue 组件中，通过 **setup** 函数来使用 Composition API；

#### setup

**setup 函数的参数**：主要有两个参数 props、context；

props：就是父组件传递过来的属性会被放到 props 对象中，我们在 setup 中如果需要使用，那么就可 以直接通过 props 参数获取；

- 定义 props 的类型的方法和之前规则一样，在 props 选项中定义；
- 在 template 中依然可以正常使用，如果想要在**setup 中使用**就可以通过第一个参数来使用，而**不能通过 this 去获取**，setup 中 this 没有指向当前组件实例。

context：包含三个属性；

- **attrs**：所有的非 prop 的 attribute，比如：id、class；
- **slots**：父组件传递过来的插槽，在以渲染函数返回时会有作用；
- **emit**：当我们组件内部需要发出事件时会用到 emit（因为我们不能访问 this，所以不可以通过 this.$emit 发出事件）；

**setup 函数的返回值**：

- setup 的返回值可以在模板 template 中被使用；
- 也就是说我们可以通过 setup 的返回值来替代 data 选项；
- 甚至是我们可以返回一个执行函数来代替在 methods 中定义的方法；
- 如果返回的是定义的变量，不是响应式变量（proxy），默认情况下，Vue 并不会跟踪它的变化，来引起界面的响应式操作；

**setup 不可以使用 this**：

- 表达的含义是**this 并没有指向当前组件实例**；
- 并且**在 setup 被调用之前，data、computed、methods 等都没有被解析**；
- 所以无法在 setup 中获取 this；

#### reactive API

如果想为在 setup 中定义的数据提供响应式的特性，那么我们可以使用 reactive 的函数；

对传入的类型是有限制的，要求我们**必须传入**的是一个**对象**或者**数组类型**；

**为什么就可以变成响应式的呢？**

- 使用 reactive 函数处理我们的数据之后，数据**再次被使用时**就会**进行依赖收集**；
- 当数据发生改变时，所有**收集到的依赖**都是**进行对应的响应式操作**（比如更新界面）；
- 事实上，我们编写的 data 选项，也是在内部交给了 reactive 函数将其编程响应式对象的；

#### ref API

- ref 会返回一个可变的响应式对象，该对象作为一个**响应式的引用**维护着它内部的值，这就是 ref 名称的来源；
- 它内部的值是在 ref 的 **value 属性**中被维护的；

注意事项：

- 在**模板中引入 ref**的值时，Vue 会**自动帮助我们进行解包操作**，所以我们并**不需要在模板中通过 ref.value** 的方式 来使用；
- 但是**在 setup 函数内部**，它依然是一个 **ref 引用**， 所以对其进行操作时，我们依然需要**使用 ref.value 的方式**；
- 如果想要使用**ref 或者元素或者组件**，可以定义一个 ref 对象，绑定到**元素或者组件的 ref 属性**上即可；

ref 是浅层的解包，我们将 ref 放到一个 reactive 的属性当中，那么在模板中使用时，它会自动解包：

```vue
<template>
  <div>
    Home Page
    <h2>{{ message }}</h2>
    <!-- 当我们在template模板中使用ref对象, 它会自动进行解包 -->
    <h2>当前计数: {{ counter }}</h2>
    <!-- ref的解包只能是一个浅层解包(info是一个普通的JavaScript对象) -->
    <h2>当前计数: {{ info.counter.value }}</h2>
    <!-- 当如果最外层包裹的是一个reactive可响应式对象, 那么内容的ref可以解包 -->
    <h2>当前计数: {{ reactiveInfo.counter }}</h2>
    <button @click="increment">+1</button>
  </div>
</template>

<script>
import { ref, reactive } from "vue";

export default {
  props: {
    message: {
      type: String,
      required: true,
    },
  },
  setup() {
    let counter = ref(100);

    const info = {
      counter,
    };

    const reactiveInfo = reactive({
      counter,
    });

    // 局部函数
    const increment = () => {
      counter.value++;
      console.log(counter.value);
    };

    return {
      counter,
      info,
      reactiveInfo,
      increment,
    };
  },
};
</script>
```

#### readonly API

通过 reactive 或者 ref 可以获取到一个响应式的对象，如果想其他组件**可以使用但不能被修改**，vue3 提供了 readonly 的方法；

readonly 会返**回原生对象的只读代理**（也就是它依然是一个 Proxy，这是一个 proxy 的 set 方法被劫持，并且不 能对其进行修改）；

**在 readonly 的使用过程中，有如下规则**：

- readonly 返回的对象都是不允许修改的；
- 但是经过 readonly 处理的原来的对象是允许被修改的；

  - 比如 const info = readonly(obj)，info 对象是不允许被修改的；
  - 当 obj 被修改时，readonly 返回的 info 对象也会被修改；
  - 但是我们不能去修改 readonly 返回的对象 info；

- 其实**本质上就是 readonly 返回的对象的 setter 方法被劫持了**而已；

#### Reactive 判断的 API

- **isProxy**

  - p 检查对象是否是由 reactive 或 readonly 创建的 proxy。

- **isReactive**

  - 检查对象是否是由 reactive 创建的响应式代理：
  - 如果该代理是 readonly 建的，但包裹了由 reactive 创建的另一个代理，它也会返回 true；

- **isReadonly**

  - 检查对象是否是由 readonly 创建的只读代理。

- **toRaw**

  - 返回 reactive 或 readonly 代理的原始对象（不建议保留对原始对象的持久引用。请谨慎使用）。

- **shallowReactive**

  - 创建一个响应式代理，它跟踪其自身 property 的响应性，但不执行嵌套对象的深层响应式转换 (深层还是原生对象)。

- **shallowReadonly**

  - 创建一个 proxy，使其自身的 property 为只读，但不执行嵌套对象的深度只读转换（深层还是可读、可写的

#### toRefs / toRef

如果我们使用**ES6 的解构语法**，对 reactive 返回的对象进行解构获取值，那么之后无论是修改结构后的变量，还是修改 reactive 返回的 state 对象，**数据都不再是响应式的**：

```javascript
const state = reactive({ name: "why", age: 18 });
const { name, age } = state;
```

**toRefs**：

Vue 为我们提供了一个**toRefs 的函数**，可以将**reactive 返回的对象中的属性都转成 ref**； 那么我们再次进行结构出来的 **name 和 age 本身都是 ref 的**；

这种做法相当于已经在**state.name 和 ref.value**之间建立了 **链接**，**任何一个修改都会引起另外一个变化**；

**toRef**：

如果我们只希望转换一个**reactive 对象中的属性为 ref**, 那么可以使用 toRef 的方法；

```vue
<template>
  <div>
    <h2>{{ name }}-{{ age }}</h2>
    <button @click="changeAge">修改age</button>
  </div>
</template>
<script>
import { reactive, toRefs, toRef } from "vue";
export default {
  setup() {
    const info = reactive({ name: "why", age: 18 });
    // 1.toRefs: 将reactive对象中的所有属性都转成ref, 建立链接
    // let { name, age } = toRefs(info);
    // 2.toRef: 对其中一个属性进行转换ref, 建立链接
    let { name } = info;
    let age = toRef(info, "age");

    const changeAge = () => {
      age.value++;
    };

    return {
      name,
      age,
      changeAge,
    };
  },
};
</script>
```

#### ref 其他的 API

- **unref**

  - 如果我们想要获取一个 ref 引用中的 value，那么也可以通过 unref 方法：
  - 如果参数是一个 ref，则返回内部值，否则返回参数本身；
  - 这是 val = isRef(val) ? val.value : val 的语法糖函数；

- **isRef**

  - 判断值是否是一个 ref 对象。

- **shallowRef**

  - 创建一个**浅层的 ref 对象**；

- **triggerRef**

  - 手动触发和 shallowRef 相关联的副作用：

#### customRef

创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显示控制：

- 它需要一个工厂函数，该函数接受 track 和 trigger 函数作为参数；
- 并且应该返回一个带有 get 和 set 的对象；

对**双向绑定的属性进行 debounce(节流)**的操作案例：

```javascript
// useDebounceRef.js
import { customRef } from "vue";
// 自定义ref
export default function (value, delay = 300) {
  let timer = null;
  return customRef((track, trigger) => {
    return {
      get() {
        track();
        return value;
      },
      set(newValue) {
        clearTimeout(timer);
        timer = setTimeout(() => {
          value = newValue;
          trigger();
        }, delay);
      },
    };
  });
}
```

#### computed 和 watch

**computed：**Options API 中，我们是使用 computed 选项来完成的；在 Composition API 中，使用 computed 方法来编写一个计算属性；

如何使用 computed？

- 方式一：接收一个 getter 函数，并为 getter 函数返回的值，返回一个不变的 ref 对象；
- 方式二：接收一个具有 get 和 set 的对象，返回一个可变的（可读写）ref 对象；

```vue
<template>
  <div>
    <h2>{{ fullName }}</h2>
    <button @click="changeName">修改firstName</button>
  </div>
</template>
<script>
import { ref, computed } from "vue";

export default {
  setup() {
    const firstName = ref("Kobe");
    const lastName = ref("Bryant");

    // 1.用法一: 传入一个getter函数
    // computed的返回值是一个ref对象
    const fullName = computed(() => firstName.value + " " + lastName.value);

    // 2.用法二: 传入一个对象, 对象包含getter/setter
    const fullName = computed({
      get: () => firstName.value + " " + lastName.value,
      set(newValue) {
        const names = newValue.split(" ");
        firstName.value = names[0];
        lastName.value = names[1];
      },
    });

    const changeName = () => {
      // firstName.value = "James"
      fullName.value = "coder why";
    };

    return {
      fullName,
      changeName,
    };
  },
};
</script>
```

**侦听数据的变化**：

- 在前面的 Options API 中，我们可以通过**watch 选项来侦听 data 或者 props**的数据变化，当数据变化时执行某一些 操作。
- 在 Composition API 中，我们可以使用**watchEffect 和 watch 来完成响应式数据的侦听**；

  - **watchEffect**用于**自动收集响应式数据的依赖**；
  - **watch**需要手动指定侦听的数据源；

**watchEffect**：

- watchEffect 传入的函数会被**立即执行一次**，并且在执行的过程中会**收集依赖**；

- 只有**收集的依赖发生变化时**，watchEffect 传入的函数**才会再次执行**；

- watchEffect 的**返回值函数**，可以用于**停止侦听**；

- 给 watchEffect 传入的函数被回调时，其实可以获取到一个参数 onInvalidate，可用于**清除副作用**：
  > 什么是清除副作用呢？

> - 比如在开发中我们需要在侦听函数中执行网络请求，但是在网络请求还没有达到的时候，我们停止了侦听器， 或者侦听器侦听函数被再次执行了。

> - 那么上一次的网络请求应该被取消掉，这个时候我们就可以清除上一次的副作用；

-

```vue
<template>
  <div>
    <h2>{{ name }}-{{ age }}</h2>
    <button @click="changeName">修改name</button>
    <button @click="changeAge">修改age</button>
  </div>
</template>
<script>
import { ref, watchEffect } from "vue";
export default {
  setup() {
    // watchEffect: 自动收集响应式的依赖
    const name = ref("why");
    const age = ref(18);

    const stop = watchEffect((onInvalidate) => {
      const timer = setTimeout(() => {
        console.log("网络请求成功~");
      }, 2000);

      // 根据name和age两个变量发送网络请求
      onInvalidate(() => {
        // 在这个函数中清除额外的副作用
        // request.cancel()
        clearTimeout(timer);
        console.log("onInvalidate");
      });
      console.log("name:", name.value, "age:", age.value);
    });

    const changeName = () => (name.value = "kobe");
    const changeAge = () => {
      age.value++;
      if (age.value > 25) {
        stop();
      }
    };

    return {
      name,
      age,
      changeName,
      changeAge,
    };
  },
};
</script>
```

- **watchEffect 的执行时机**：

  - setup 函数在执行时会立即执行传入的副作用函数，所以打印为 null；

  - 而当 DOM 挂载时，会给 title 的 ref 对象赋值新的值，副作用函数会再次执行，打印出来对应的元素；

  - 如果我们希望在第一次的时候就打印出来对应的元素：

    - 需要改变副作用函数的执行时机；
    - 它的默认值是 **pre**，它会在**元素 挂载 或者 更新 之前执行**；
    - 设置为 **post**，就可以在 dom 挂载后执行
    - flush 选项还接受 sync，这将强制效果始终同步触发。然而，这是低效的，应该很少需要。

  -

```vue
<template>
  <div>
    <h2 ref="title">哈哈哈</h2>
  </div>
</template>
<script>
import { ref, watchEffect } from "vue";
export default {
  setup() {
    const title = ref(null);

    watchEffect(
      () => {
        console.log(title.value);
      },
      {
        flush: "post",
      }
    );

    return {
      title,
    };
  },
};
</script>
```

**watch**：

- watch 的 API 完全等同于组件 watch 选项的 Property：

  - watch 需要侦听特定的数据源，并在回调函数中执行副作用；
  - 默认情况下它是**惰性的**，只有当**被侦听的源发生变化时才会执行回调**；

- 与 watchEffect 的比较，watch 允许我们：

  - **懒执行**副作用（第一次不会直接执行）；
  - **更具体的说明当哪些状态发生变化**时，**触发侦听器的执行**；
  - 访问**侦听状态变化前后的值**；

- watch 侦听函数的数据源有两种类型：

  - 一个**getter 函数**：但是该 getter 函数必须引用**可响应式的对象**（比如 reactive 或者 ref）；
  - **直接写入一个可响应式的对象**，reactive 或者 ref（比较常用的是 ref）；

- 侦听器还可以**使用数组同时侦听多个源**；

- 如果我们希望**侦听一个数组或者对象**，那么可以**使用一个 getter 函数，并且对可响应对象进行解构**；

- watch 的第三个参数可以传入一个对象对 watch 进行配置：

  - 侦听一个**深层的侦听**，那么依然需要**设置 deep 为 true**；
  - 传入 **immediate** **立即执行**；

```vue
<template>
  <div>
    <h2 ref="title">{{ info.name }}</h2>
    <button @click="changeData">修改数据</button>
  </div>
</template>
<script>
import { ref, reactive, watch } from "vue";
export default {
  setup() {
    const info = reactive({ name: "why", age: 18 });

    // 1.侦听watch时,传入一个getter函数
    watch(
      () => info.name,
      (newValue, oldValue) => {
        console.log("newValue:", newValue, "oldValue:", oldValue);
      }
    );

    // 2.传入一个可响应式对象: reactive对象/ref对象
    // 情况一: reactive对象获取到的newValue和oldValue本身都是reactive对象
    // watch(info, (newValue, oldValue) => {
    //   console.log("newValue:", newValue, "oldValue:", oldValue);
    // })
    // 如果希望newValue和oldValue是一个普通的对象
    watch(
      () => {
        return { ...info };
      },
      (newValue, oldValue) => {
        console.log("newValue:", newValue, "oldValue:", oldValue);
      }
    );
    // 情况二: ref对象获取newValue和oldValue是value值的本身
    // const name = ref("why");
    // watch(name, (newValue, oldValue) => {
    //   console.log("newValue:", newValue, "oldValue:", oldValue);
    // })

    const changeData = () => {
      info.name = "kobe";
    };

    return {
      changeData,
      info,
    };
  },
};
</script>
```

#### 生命周期钩子

与 Options API 类似，通过 import 导入 onX 函数注册生命周期钩子；

#### provide / inject

- provide：传入两个参数： **name：提供的属性名称** 和 **value：提供的属性值**；
- inject：传入两个参数： **要 inject 的 property 的 name** 和 **默认值**；
- 为了增加 provide 值和 inject 值之间的响应性，我们可以在 provide 值时使用 ref 和 reactive；
- 如果我们需要修改可响应的数据，那么最好是在数据提供的位置来修改；

```vue
// App.vue
<template>
  <div>
    <home />
    <h2>App Counter: {{ counter }}</h2>
    <button @click="increment">App中的+1</button>
  </div>
</template>
<script>
import { provide, ref, readonly } from "vue";
import Home from "./Home.vue";
export default {
  components: {
    Home,
  },
  setup() {
    const name = ref("coderwhy");
    let counter = ref(100);

    provide("name", readonly(name));
    provide("counter", readonly(counter));

    const increment = () => counter.value++;

    return {
      increment,
      counter,
    };
  },
};
</script>
```

```vue
// Home.vue
<template>
  <div>
    <h2>{{ name }}</h2>
    <h2>{{ counter }}</h2>

    <button @click="homeIncrement">home+1</button>
  </div>
</template>
<script>
import { inject } from "vue";
export default {
  setup() {
    const name = inject("name");
    const counter = inject("counter");

    const homeIncrement = () => counter.value++;

    return {
      name,
      counter,
      homeIncrement,
    };
  },
};
</script>
```

#### 自定义 hooks

```javascript
// useCounter.js
import { ref, computed } from "vue";
export default function () {
  const counter = ref(0);
  const doubleCounter = computed(() => counter.value * 2);

  const increment = () => counter.value++;
  const decrement = () => counter.value--;

  return {
    counter,
    doubleCounter,
    increment,
    decrement,
  };
}
```

```vue
// App.vue
<template>
  <div>
    <h2>当前计数: {{counter}}</h2>
    <h2>计数*2: {{doubleCounter}}</h2>
    <button @click="increment">+1</button>
    <button @click="decrement">-1</button>
</template>

<script>
  import { ref, computed } from 'vue';
  import {
    useCounter,
  } from './hooks';

  export default {
    setup() {
      // counter
      const { counter, doubleCounter, increment, decrement } = useCounter();

      return {
        counter,
        doubleCounter,
        increment,
        decrement,
      }
    }
  }
</script>
```

#### setup 顶层编写方式

```vue
// App.vue
<template>
  <div>
    <h2>当前计数: {{ counter }}</h2>
    <button @click="increment">+1</button>

    <hello-world message="呵呵呵" @increment="getCounter"></hello-world>
  </div>
</template>
<script setup>
import { ref } from "vue";
import HelloWorld from "./HelloWorld.vue";

const counter = ref(0);
const increment = () => counter.value++;

const getCounter = (payload) => {
  console.log(payload);
};
</script>
```

```vue
// HelloWorld.vue
<template>
  <div>
    <h2>Hello World</h2>
    <h2>{{ message }}</h2>
    <button @click="emitEvent">发射事件</button>
  </div>
</template>
<script setup>
import { defineProps, defineEmit } from "vue";

const props = defineProps({
  message: {
    type: String,
    default: "哈哈哈",
  },
});

const emit = defineEmit(["increment", "decrement"]);

const emitEvent = () => {
  emit("increment", "100000");
};
</script>
```

## 高级语法

#### h 函数

h() 函数是一个用于**创建 vnode** 的一个函数； 其实更准确的命名是 createVNode() 函数，但是为了简便在 Vue 将之简化为 h() 函数；

h 函数可以在两个地方使用：

- render 函数选项中；
- setup 函数选项中；

类似于 React 的 creatElement，传入三个参数：

- **type**

  - **类型：**`String | Object | Function`；
  - **详细：**HTML 标签名、组件、异步组件或函数式组件。使用返回 null 的函数将渲染一个注释。此参数是必需的。

- **props**

  - **类型：**`Object`
  - **详细：**一个对象，与我们将在模板中使用的 attribute、prop 和事件相对应。可选。

- **children**

  - **类型：**`String | Array | Object`
  - **详细：**子代 VNode，使用 `h()` 生成，或者使用字符串来获取“文本 VNode”，或带有插槽的对象。可选。

```vue
<script>
import { ref, h } from "vue";

export default {
  setup() {
    const counter = ref(0);

    return () => {
      return h("div", { class: "app" }, [
        h("h2", null, `当前计数: ${counter.value}`),
        h(
          "button",
          {
            onClick: () => counter.value++,
          },
          "+1"
        ),
        h(
          "button",
          {
            onClick: () => counter.value--,
          },
          "-1"
        ),
      ]);
    };
  },
};
</script>
```

#### jsx 的使用

如果我们希望在项目中使用 jsx，那么我们需要添加对 jsx 的支持，通过 Babel 来进行转换，并在 babel.config.js 配置文件中配置插件；

`npm install @vue/babel-plugin-jsx -D`

```vue
<script>
export default {
  data() {
    return {
      counter: 0,
    };
  },

  render() {
    const increment = () => this.counter++;
    const decrement = () => this.counter--;

    return (
      <div>
        <h2>当前计数: {this.counter}</h2>
        <button onClick={increment}>+1</button>
        <button onClick={decrement}>-1</button>
      </div>
    );
  },
};
</script>
```

## Vue3.0 新特性以及使用经验总结

[掘金](https://juejin.cn/post/6940454764421316644)<br />
这篇文章通过实际使用了 vue3 进行了对 vue3 新特性总结，以及对 vue2.x 进行比较。

---
